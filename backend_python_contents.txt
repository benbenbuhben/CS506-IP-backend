-e \n\n--- Filename: ./AI_player.py ---\n\n
import random


class ArtificialPlayer:
    def __init__(self, symbol):
        self.symbol = symbol

    def get_move(self, board):
        """
        This function purpose is get move
        """
        possible_moves = board.get_possible_moves()
        best_move = self.best_move(board, possible_moves)
        return best_move
    
    def best_move(self, board, possible_moves):
        """
        This function purpose is best move
        """
        # get moves of AI player and opponent player
        if self.symbol == 'X':
            ai_moves = board.xCoordinates
            opponent_moves = board.oCoordinates
        else:
            ai_moves = board.oCoordinates
            opponent_moves = board.xCoordinates
        win_conditions = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24],  # Horizontals
            [0, 5, 10, 15, 20],
            [1, 6, 11, 16, 21],
            [2, 7, 12, 17, 22],
            [3, 8, 13, 18, 23],
            [4, 9, 14, 19, 24],  # Verticals
            [0, 6, 12, 18, 24],
            [4, 8, 12, 16, 20],  # Diagonals
        ]
        win_possibility = 0
        for condition in win_conditions:
            for con in condition:
                if con in ai_moves:
                    win_possibility += 1
            if win_possibility == 4:
                for con in condition:
                    if con in possible_moves:
                        return con
            win_possibility = 0
        for condition in win_conditions:
            for con in condition:
                if con in opponent_moves:
                    win_possibility += 1
            if win_possibility == 4:
                for con in condition:
                    if con in possible_moves:
                        return con
            win_possibility = 0        
        return random.choice(possible_moves)-e \n\n--- Filename: ./board.py ---\n\n
class Board:
    def __init__(self):
        self.board = [" " for _ in range(25)]
        self.xCoordinates = list()
        self.oCoordinates = list()

    def make_move(self, position, player):
        if self.is_valid_move(position):
            self.board[position] = player
            if player == 'X':
                self.xCoordinates.append(position)
            else:
                self.oCoordinates.append(position)
            return True
        return False

    def is_valid_move(self, position):
        return 0 <= position < 25 and self.board[position] == " "

    def check_winner(self):
        win_conditions = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24],  # Horizontals
            [0, 5, 10, 15, 20],
            [1, 6, 11, 16, 21],
            [2, 7, 12, 17, 22],
            [3, 8, 13, 18, 23],
            [4, 9, 14, 19, 24],  # Verticals
            [0, 6, 12, 18, 24],
            [4, 8, 12, 16, 20],  # Diagonals
        ]
        for condition in win_conditions:
            if (
                self.board[condition[0]]
                == self.board[condition[1]]
                == self.board[condition[2]]
                == self.board[condition[3]]
                == self.board[condition[4]]
                != " "
            ):
                return True, condition  # Return the winning line
        return False, None

    def is_full(self):
        return " " not in self.board

    def get_board(self):
        return self.board
    
    def get_possible_moves(self):
        """
        This function purpose is get possible moves
        """
        possible_moves = list()
        for i in range(25):
            if i not in self.xCoordinates and i not in self.oCoordinates:
                possible_moves.append(i)
        return possible_moves-e \n\n--- Filename: ./game.py ---\n\n
import random
from board import Board
from AI_player import ArtificialPlayer


class Game:
    def __init__(self, game_id, is_ai=False):
        self.game_id = game_id
        self.board = Board()
        self.players = {}
        self.is_ai = is_ai
        self.current_player = "X"
        self.moves = []
        self.ai_player = ArtificialPlayer("O")

    def add_player(self, player_id):
        """Assigns a symbol to the new player."""
        if len(self.players) == 0:
            self.players[player_id] = "X"
        elif len(self.players) == 1:
            self.players[player_id] = "O"
        return self.players[player_id]

    @property
    def game_status(self):
        """Return the current status of the game."""
        if len(self.players) == 1:
            return "Waiting for other player"
        elif len(self.players) == 2:
            return "Active"
        else:
            return "Not started"

    def switch_player(self):
        self.current_player = "O" if self.current_player == "X" else "X"

    def make_move(self, position):
        if self.board.make_move(position, self.current_player):
            self.moves.append(f"{self.current_player}:{position}")
            self.switch_player()
            return True
        return False

    def reset_game(self):
        self.board = Board()
        self.current_player = "X"
        self.moves = []

    def get_game_state(self):
        winner, winning_line = self.board.check_winner()
        if winning_line and winning_line[0] in self.board.xCoordinates:
            winnerPlayer = "X"
        elif winning_line and winning_line[0] in self.board.oCoordinates:
            winnerPlayer = "O"
        else:
            winnerPlayer = None
        return {
            "game_id": self.game_id,
            "board": self.board.get_board(),
            "current_player": self.current_player,
            "winner": winner,
            "winning_line": winning_line,
            "draw": self.board.is_full() and not winner,
            "moves": self.moves,
            "game_status": self.game_status,
            "winnerPlayer": winnerPlayer,
            "is_ai": self.is_ai,
        }
-e \n\n--- Filename: ./app.py ---\n\n
import os
from flask import Flask, jsonify, request
from flask_socketio import SocketIO, emit, join_room
from flask_cors import CORS
from game import Game
from gevent import monkey
from dotenv import load_dotenv
import json

# Apply gevent monkey patching
monkey.patch_all()

# Load environment variables
load_dotenv()

host = os.environ.get("HOST", "localhost")
port = int(os.environ.get("PORT", 5001))

# Initialize Flask app
app = Flask(__name__)
app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY")

# Enable CORS for all routes
CORS(app)

# Initialize SocketIO with gevent
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="gevent")

# Dictionary to store games
games = {}


# Routes
@app.route("/")
def hello():
    return "Hello, World!"


@socketio.on("test_connection")
def handle_test_connection(data):
    print("Test Connection Received:", data)
    emit("connection_response", {"message": "Connection Successful"})


@app.route("/new_game", methods=["POST"])
def new_game():
    game_id = generate_unique_game_id()
    print(request.json)
    is_ai = request.json.get("ai")
    games[game_id] = Game(game_id, is_ai=is_ai)
    return jsonify({"game_id": game_id}), 200


@socketio.on("join_game")
def handle_join_game(data):
    player_id = request.sid
    game_id = data.get("game_id")
    join_room(game_id)
    game = games.get(game_id)

    if game:
        # Add player and get their assigned symbol
        symbol = game.add_player(player_id)

        # Get the general game state
        general_game_state = game.get_game_state()

        # Emit the general game state to the room (without player_symbol)
        emit("game_state", general_game_state, room=game_id, include_self=False)

        # Emit personalized game state to the player who just joined
        personalized_game_state = general_game_state.copy()
        personalized_game_state["player_symbol"] = symbol
        emit("game_state", personalized_game_state, to=player_id)

        if game.is_ai and len(game.players) == 1:
            # Add AI player
            symbol = game.add_player("ai")
            # Emit personalized game state to the AI player
            personalized_game_state = general_game_state.copy()
            personalized_game_state["player_symbol"] = symbol
            emit("game_state", personalized_game_state, to="ai")
        else:
            # Emit personalized game state to other players
            for pid in game.players:
                if pid != player_id:  # Skip the player who just joined
                    personalized_game_state = general_game_state.copy()
                    personalized_game_state["player_symbol"] = game.players[pid]
                    emit("game_state", personalized_game_state, to=pid)
    else:
        emit("game_error", {"error": "Game not found"}, to=player_id)


@socketio.on("make_move")
def handle_make_move(data):
    print("Received move:", data)
    game_id = data.get("game_id")
    position = data.get("position")

    game = games.get(game_id)
    if not game:
        print("Game not found")
        emit("game_error", {"error": "Game not found"})
        return

    if game.make_move(position):
        for pid, symbol in game.players.items():
            personalized_game_state = game.get_game_state()
            personalized_game_state["player_symbol"] = symbol
            emit("game_state", personalized_game_state, to=pid)
            print(game.get_game_state())
    if game.is_ai and game.current_player == "O":
        # AI player move
        position = game.ai_player.get_move(game.board)
        game.make_move(position)
        for pid, symbol in game.players.items():
            personalized_game_state = game.get_game_state()
            personalized_game_state["player_symbol"] = symbol
            emit("game_state", personalized_game_state, to=pid)
    else:
        print("Invalid move")
        emit("game_error", {"error": "Invalid move"})


@socketio.on("reset_game")
def handle_reset_game(data):
    game_id = data.get("game_id")
    game = games.get(game_id)
    if game:
        game.reset_game()
        updated_game_state = game.get_game_state()
        for pid, symbol in game.players.items():
            personalized_game_state = updated_game_state.copy()
            personalized_game_state["player_symbol"] = symbol
            emit("game_state", personalized_game_state, to=pid)
    else:
        emit("game_error", {"error": "Game not found"}, room=game_id)


# Helper function to generate a unique game ID
def generate_unique_game_id():
    import uuid

    return str(uuid.uuid4())


# Main entry point
if __name__ == "__main__":
    socketio.run(app, host=host, debug=False, port=port)
